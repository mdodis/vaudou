"#include \"vd.structs.glsl\"\n"
"\n"
"layout (set = 0, binding = 0) uniform VD_R_SceneData {\n"
"    mat4 view;\n"
"    mat4 proj;\n"
"    vec3 sun_direction;\n"
"    vec3 sun_color;\n"
"} vd_scene_data;\n"
"\n"
"vec4 object_space_to_ndc(mat4 obj, vec3 position) {\n"
"    return vd_scene_data.proj * vd_scene_data.view * obj * vec4(position, 1.0);\n"
"}\n"
"\n"
"vec3 eye_position() {\n"
"    mat3 rotation = mat3(vd_scene_data.view);\n"
"    vec3 translation = vec3(vd_scene_data.view[3]);\n"
"    return -rotation * translation;\n"
"}\n"
"\n"
"vec3 eye_direction() {\n"
"    return -vec3(vd_scene_data.view[2][0], vd_scene_data.view[2][1], vd_scene_data.view[2][2]);\n"
"}\n"
"\n"
"// @todo: Implementation of the specular D term in GLSL optimized for fp16\n"
"float d_ggx(float NoH, float a) {\n"
"    float a2 = a * a;\n"
"    // float f = (NoH * a2 - NoH) * NoH + 1.0;\n"
"    float f = (NoH * NoH * (a2 - 1.0) + 1.0);\n"
"    return a2 / (PI * f * f);\n"
"}\n"
"\n"
"vec3 f_schlick(float u, vec3 f0) {\n"
"    return f0 + (1.0 - f0) * pow(clamp(1.0 - u, 0.0, 1.0), 5.0);\n"
"}\n"
"\n"
"float g_schlickggx(float NoV, float a)\n"
"{\n"
"    float r = (a + 1.0);\n"
"    float k = (r * r) / 8.0;\n"
"    float nom = NoV;\n"
"    float denom = NoV * (1.0 - k) + k;\n"
"\n"
"    return nom / denom;\n"
"}\n"
"\n"
"float v_smithggx_correlated(float NoV, float NoL, float a) {\n"
"    float ggx2 = g_schlickggx(NoV, a);\n"
"    float ggx1 = g_schlickggx(NoL, a);\n"
"    return ggx1 * ggx2;\n"
"}\n"
"\n"
"float fd_lambert() {\n"
"    return 1.0 / PI;\n"
"}\n"
"";
